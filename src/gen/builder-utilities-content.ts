/**
 * Auto-generated embedded content from builder-utilities.ts
 * DO NOT EDIT THIS FILE MANUALLY - it will be overwritten during build
 */

export const BUILDER_UTILITIES_CONTENT = `/**
 * Runtime utilities for fluent builders
 * Core functionality for builder pattern implementation
 */

/**
 * Unique symbol for identifying fluent builders
 * Used across module boundaries for proper type identification
 */
export const FLUENT_BUILDER_SYMBOL = Symbol.for('fluent-builder');

/**
 * Parameters for nested context generation
 * Used by parent builder to create context for child builders
 *
 * IMPORTANT: Due to the deferred pattern, child builders are NOT executed when context is created.
 * The parent can only use information from its own state and parent context.
 * Children should augment context in their own build() method before passing to grandchildren.
 */
export interface NestedContextParams<C extends BaseBuildContext> {
  /** Context from parent builder */
  readonly parentContext: C;
  /** Name of the parameter being built */
  readonly parameterName: string;
  /** Index in array if building array elements */
  readonly index?: number;
}

/**
 * Function type for generating nested context
 * Allows users to customize how context is passed from parent to child builders
 *
 * IMPORTANT: This function is called by the PARENT before the child builder executes.
 * You can only access parent context and parameter metadata, NOT child builder state.
 * If you need child-specific data in context, the child must augment context in its build() method.
 *
 * @example
 * const generator: NestedContextGenerator<MyContext> = ({ parentContext, parameterName, index }) => {
 *   let nodeId = parentContext.nodeId || 'root';
 *   nodeId += \`-\${parameterName}\`;
 *   if (index !== undefined) nodeId += \`-\${index}\`;
 *   return { ...parentContext, parameterName, index, nodeId, __nestedContextGenerator__: generator };
 * };
 */
export type NestedContextGenerator<C extends BaseBuildContext> = (
  params: NestedContextParams<C>,
) => C;

/**
 * Base context interface for builder operations
 * Provides information about the builder's position in the object hierarchy
 *
 * The __nestedContextGenerator__ uses a type assertion pattern to allow
 * contexts to carry generators that produce their own extended type.
 */
export interface BaseBuildContext {
  readonly parentId?: string;
  readonly parameterName?: string;
  readonly index?: number;
  readonly __nestedContextGenerator__?: NestedContextGenerator<any>;
  readonly [key: string]: unknown;
}

/**
 * Core fluent builder interface
 * All generated builders implement this interface
 */
export interface FluentBuilder<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL]: true;
  /**
   * Builds the final object
   * @param context - Optional build context
   */
  build(context?: C): T;
  /**
   * Get current value without building (useful for conditional logic and context generation)
   * @param key - The property key
   * @returns The current value or undefined
   */
  peek<K extends keyof T>(key: K): T[K] | undefined;
  /**
   * Checks if a property has been set
   * @param key - The property key to check
   */
  has<K extends keyof T>(key: K): boolean;
}

/**
 * Metadata for mixed arrays containing both builders and static values
 * Stores array once with indices marking builders and objects-with-builders
 */
interface MixedArrayMetadata {
  /** The actual array with mixed content */
  readonly array: readonly unknown[];
  /** Set of indices where builders are located */
  readonly builderIndices: ReadonlySet<number>;
  /** Set of indices where objects containing builders are located */
  readonly objectIndices: ReadonlySet<number>;
}

/**
 * Type guard to check if a value is a fluent builder
 * Uses Symbol.for to ensure proper identification across module boundaries
 * @param value - Value to check
 * @returns True if value is a fluent builder
 */
export function isFluentBuilder<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is FluentBuilder<T, C> {
  if (value === null || typeof value !== 'object') {
    return false;
  }

  if (!(FLUENT_BUILDER_SYMBOL in value)) {
    return false;
  }

  const obj = value as Record<symbol | string, unknown>;

  return obj[FLUENT_BUILDER_SYMBOL] === true && typeof obj.build === 'function';
}

/**
 * Type guard to check if a value is a builder array
 * @param value - Value to check
 * @returns True if value is an array where all items are builders (empty arrays return true)
 */
export function isBuilderArray<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is Array<FluentBuilder<T, C>> {
  return Array.isArray(value) && value.every(isFluentBuilder);
}

/**
 * Builds context parameters with optional index
 */
function buildContextParams<C extends BaseBuildContext>(
  parentContext: C,
  parameterName: string,
  index?: number,
): NestedContextParams<C> {
  const params: NestedContextParams<C> = {
    parentContext,
    parameterName,
  };
  if (index !== undefined) {
    return { ...params, index };
  }
  return params;
}

/**
 * Creates a new context for nested builders with proper inheritance
 * Supports custom context generation via __nestedContextGenerator__
 *
 * IMPORTANT: Due to the deferred pattern, this is called by the parent BEFORE the child executes.
 * The parent can only pass information from its own context and parameter metadata.
 * Children should augment the context in their build() method if they need to add child-specific data.
 *
 * @param params - Named parameters for context creation
 * @param params.parentContext - Context from parent builder
 * @param params.parameterName - Name of the parameter being built
 * @param params.index - Optional array index
 * @returns New context with inherited properties
 */
export function createNestedContext<C extends BaseBuildContext>(params: {
  readonly parentContext: C;
  readonly parameterName: string;
  readonly index?: number;
}): C {
  const { parentContext, parameterName, index } = params;

  // Use custom generator if provided (runtime check ensures type safety)
  if (parentContext.__nestedContextGenerator__) {
    const contextParams = buildContextParams(parentContext, parameterName, index);
    const generated = parentContext.__nestedContextGenerator__(contextParams);
    // The generator is expected to return a context compatible with C
    return generated as C;
  }

  // Default behavior: spread parent context and add new properties
  // Create new context with all properties at once to avoid readonly assignment issues
  const newContext: BaseBuildContext =
    index !== undefined
      ? {
          ...parentContext,
          parameterName,
          index,
        }
      : {
          ...parentContext,
          parameterName,
        };

  // Type assertion is safe: we're creating an object that extends BaseBuildContext
  // with all properties from C (via spread) plus our new properties
  return newContext as C;
}

/**
 * Checks if value is a plain object (works across realms)
 */
function isPlainObject(value: unknown): value is Record<string, unknown> {
  if (!value || typeof value !== 'object') return false;
  const proto = Object.getPrototypeOf(value);
  // Plain objects have Object.prototype or null as prototype
  return proto === Object.prototype || proto === null;
}

/**
 * Recursively resolves builders in a value
 * Handles circular references by tracking visited objects
 * @param value - Value to resolve
 * @param context - Optional build context
 * @param visited - WeakSet tracking visited objects to prevent infinite recursion
 * @returns Resolved value with all builders built
 */
export function resolveValue<T, C extends BaseBuildContext>(
  value: unknown,
  context?: C,
  visited: WeakSet<object> = new WeakSet(),
): unknown {
  if (isFluentBuilder<T, C>(value)) {
    return value.build(context);
  }

  if (Array.isArray(value)) {
    // Handle circular references
    if (visited.has(value)) return value;
    visited.add(value);

    return value.map((item, index) => {
      const arrayContext = context
        ? createNestedContext({ parentContext: context, parameterName: 'array', index })
        : undefined;
      return resolveValue(item, arrayContext, visited);
    });
  }

  if (isPlainObject(value)) {
    // Handle circular references
    if (visited.has(value)) return value;
    visited.add(value);

    const resolved: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      const nestedContext = context
        ? createNestedContext({ parentContext: context, parameterName: key })
        : undefined;
      resolved[key] = resolveValue(val, nestedContext, visited);
    }
    return resolved;
  }

  return value;
}

/**
 * Base class for all generated builders
 * Provides core functionality for the builder pattern
 */
export abstract class FluentBuilderBase<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL] = true;
  protected values: Partial<T> = {};
  protected builders = new Map<string, FluentBuilder<unknown, C> | Record<string, unknown>>();
  protected mixedArrays = new Map<string, MixedArrayMetadata>();
  protected auxiliaryData = new Map<string, unknown>();
  protected context?: C;

  /**
   * Creates a new builder instance
   * @param initial - Optional initial values
   */
  constructor(initial?: Partial<T>) {
    if (initial) {
      this.values = { ...initial };
    }
  }

  /**
   * Sets a property value, handling both regular values and nested builders
   * @param key - The property key
   * @param value - The value or builder to set
   */
  protected set<K extends keyof T>(key: K, value: unknown): this {
    const keyStr = String(key);

    if (isFluentBuilder(value)) {
      this.builders.set(keyStr, value);
      // Clear from values and mixed arrays if they were there
      delete this.values[key];
      this.mixedArrays.delete(keyStr);
    } else if (Array.isArray(value)) {
      // Handle mixed arrays (builders + static values)
      const builderIndices = new Set<number>();
      const objectIndices = new Set<number>();

      value.forEach((item, index) => {
        if (isFluentBuilder(item)) {
          builderIndices.add(index);
        } else if (typeof item === 'object' && item !== null && this.containsBuilder(item)) {
          objectIndices.add(index);
        }
      });

      const hasBuilders = builderIndices.size > 0 || objectIndices.size > 0;

      if (hasBuilders) {
        // Store array with metadata - single storage, O(1) lookups during build
        this.mixedArrays.set(keyStr, {
          array: value,
          builderIndices,
          objectIndices,
        });
        // Clear from values
        delete this.values[key];
      } else {
        // Pure static array
        this.values[key] = value as T[K];
        // Clear from mixed arrays if it was there
        this.mixedArrays.delete(keyStr);
      }
      // Always clear from builders for arrays (using new storage)
      this.builders.delete(keyStr);
    } else if (typeof value === 'object' && value !== null && this.containsBuilder(value)) {
      // Object containing builders
      this.builders.set(keyStr, value as Record<string, unknown>);
      delete this.values[key];
      this.mixedArrays.delete(keyStr);
    } else {
      // Static value
      this.values[key] = value as T[K];
      // Clear from builders and mixed arrays if they were there
      this.builders.delete(keyStr);
      this.mixedArrays.delete(keyStr);
    }
    return this;
  }

  /**
   * Checks if an object contains any builders recursively
   * Handles circular references gracefully
   */
  private containsBuilder(obj: unknown, visited: WeakSet<object> = new WeakSet()): boolean {
    if (isFluentBuilder(obj)) return true;

    if (!obj || typeof obj !== 'object') return false;

    // Handle circular references
    if (visited.has(obj)) return false;
    visited.add(obj);

    // Check arrays recursively
    if (Array.isArray(obj)) {
      return obj.some(item => this.containsBuilder(item, visited));
    }

    // Only check plain objects (works across realms)
    const proto = Object.getPrototypeOf(obj);
    if (proto === Object.prototype || proto === null) {
      return Object.values(obj).some(val => this.containsBuilder(val, visited));
    }

    return false;
  }

  /**
   * Builds the final object with defaults and nested builder resolution
   * @param defaults - Optional default values
   * @param context - Optional build context
   */
  protected buildWithDefaults(defaults?: Partial<T>, context?: C): T {
    const result: Record<string, unknown> = defaults ? { ...defaults } : {};

    // Apply explicitly set values
    Object.assign(result, this.values);

    // Process mixed arrays with O(1) Set lookups
    this.mixedArrays.forEach((metadata, key) => {
      const { array, builderIndices, objectIndices } = metadata;
      const resolvedArray: unknown[] = Array.from({ length: array.length });

      array.forEach((item, index) => {
        if (builderIndices.has(index)) {
          // This is a builder - build it with context
          const nestedContext = context
            ? createNestedContext({ parentContext: context, parameterName: key, index })
            : undefined;
          resolvedArray[index] = (item as FluentBuilder<unknown, C>).build(nestedContext);
        } else if (objectIndices.has(index)) {
          // This is an object containing builders - resolve recursively
          const nestedContext = context
            ? createNestedContext({ parentContext: context, parameterName: key, index })
            : undefined;
          resolvedArray[index] = resolveValue(item, nestedContext);
        } else {
          // Static value - copy as-is
          resolvedArray[index] = item;
        }
      });
      result[key] = resolvedArray;
    });

    // Process regular builders (non-array)
    this.builders.forEach((value, key) => {
      const nestedContext = context
        ? createNestedContext({ parentContext: context, parameterName: key })
        : undefined;
      result[key] = resolveValue(value, nestedContext);
    });

    // Type assertion is safe here as we're building from typed values
    return result as T;
  }

  /**
   * Resolves a value or function to its final value
   */
  private resolveValueOrFunction<K extends keyof T>(
    value: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>),
  ): T[K] | FluentBuilder<T[K], C> {
    if (typeof value === 'function' && !isFluentBuilder(value)) {
      return (value as () => T[K] | FluentBuilder<T[K], C>)();
    }
    return value as T[K] | FluentBuilder<T[K], C>;
  }

  /**
   * Conditionally sets a property based on a predicate
   * @param predicate - Function to determine if the property should be set
   * @param property - The property key
   * @param value - The value or value generator
   */
  public if<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    value: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>),
  ): this {
    if (predicate(this)) {
      this.set(property, this.resolveValueOrFunction(value));
    }
    return this;
  }

  /**
   * Conditionally sets a property choosing between two values
   * @param predicate - Function to determine which value to use
   * @param property - The property key
   * @param trueValue - Value to use if predicate is true
   * @param falseValue - Value to use if predicate is false
   */
  public ifElse<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    trueValue: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>),
    falseValue: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>),
  ): this {
    const valueToUse = predicate(this) ? trueValue : falseValue;
    this.set(property, this.resolveValueOrFunction(valueToUse));
    return this;
  }

  /**
   * Checks if a property has been set
   * @param key - The property key to check
   */
  public has<K extends keyof T>(key: K): boolean {
    const keyStr = String(key);
    return key in this.values || this.builders.has(keyStr) || this.mixedArrays.has(keyStr);
  }

  /**
   * Get current value without building (useful for conditional logic and context generation)
   * Returns the raw value if static, or undefined if it's a builder (since builders are deferred)
   * For mixed arrays, returns the array (which may contain unbuilt builders)
   * @param key - The property key
   * @returns The current value or undefined
   */
  public peek<K extends keyof T>(key: K): T[K] | undefined {
    const keyStr = String(key);

    // Check mixed arrays first
    const mixedArray = this.mixedArrays.get(keyStr);
    if (mixedArray) {
      return mixedArray.array as T[K];
    }

    // Check builders - return undefined since they're not built yet
    if (this.builders.has(keyStr)) {
      return undefined;
    }

    // Return static value
    return this.values[key];
  }

  /**
   * Get builder for a property if one is set
   * Returns undefined if the property is not a builder or not set
   * @param key - The property key
   * @returns The builder instance or undefined
   */
  public peekBuilder<K extends keyof T>(key: K): FluentBuilder<T[K], C> | undefined {
    const keyStr = String(key);
    const entry = this.builders.get(keyStr);
    if (!entry) return undefined;

    // Return only if it's actually a FluentBuilder
    if (isFluentBuilder<T[K], C>(entry)) {
      return entry;
    }
    return undefined;
  }

  /**
   * Get the type of value stored for a property
   * Useful for determining how to handle the property
   * @param key - The property key
   * @returns The value type: 'static', 'builder', 'mixed-array', or 'unset'
   */
  public getValueType<K extends keyof T>(key: K): 'static' | 'builder' | 'mixed-array' | 'unset' {
    const keyStr = String(key);

    if (this.mixedArrays.has(keyStr)) {
      return 'mixed-array';
    }

    if (this.builders.has(keyStr)) {
      return 'builder';
    }

    if (key in this.values) {
      return 'static';
    }

    return 'unset';
  }

  /**
   * Clones the builder, creating an independent copy with the same state
   * Useful for creating variations or branching builder chains
   * @returns A new builder instance with copied state
   */
  public clone(): this {
    const cloned = new (this.constructor as new () => this)();
    cloned.values = { ...this.values };
    cloned.builders = new Map(this.builders);
    cloned.mixedArrays = new Map(
      Array.from(this.mixedArrays.entries()).map(([key, metadata]) => [
        key,
        {
          array: metadata.array,
          builderIndices: new Set(metadata.builderIndices),
          objectIndices: new Set(metadata.objectIndices),
        },
      ]),
    );
    cloned.auxiliaryData = new Map(this.auxiliaryData);
    if (this.context) {
      cloned.context = this.context;
    }
    return cloned;
  }

  /**
   * Unsets a property, removing it from the builder
   * @param key - The property key to unset
   * @returns The builder instance for chaining
   */
  public unset<K extends keyof T>(key: K): this {
    const keyStr = String(key);
    delete this.values[key];
    this.builders.delete(keyStr);
    this.mixedArrays.delete(keyStr);
    return this;
  }

  /**
   * Clears all properties from the builder, resetting it to initial state
   * Auxiliary data is preserved
   * @returns The builder instance for chaining
   */
  public clear(): this {
    this.values = {};
    this.builders.clear();
    this.mixedArrays.clear();
    return this;
  }

  /**
   * Set auxiliary data (for plugins and deferred operations)
   * @param key - Unique key for the auxiliary data
   * @param value - Value to store
   */
  protected setAuxiliary<TAux>(key: string, value: TAux): this {
    this.auxiliaryData.set(key, value);
    return this;
  }

  /**
   * Get auxiliary data (for plugins and deferred operations)
   * @param key - Unique key for the auxiliary data
   * @returns The auxiliary data or undefined
   */
  protected getAuxiliary<TAux>(key: string): TAux | undefined {
    return this.auxiliaryData.get(key) as TAux | undefined;
  }

  /**
   * Push item to auxiliary array (creates array if doesn't exist)
   * @param key - Unique key for the auxiliary array
   * @param item - Item to push to the array
   */
  protected pushAuxiliary<TAux>(key: string, item: TAux): this {
    const existing = this.auxiliaryData.get(key) as TAux[] | undefined;
    if (existing && Array.isArray(existing)) {
      existing.push(item);
    } else {
      this.auxiliaryData.set(key, [item]);
    }
    return this;
  }

  /**
   * Get auxiliary array (returns empty array if doesn't exist)
   * @param key - Unique key for the auxiliary array
   * @returns The auxiliary array
   */
  protected getAuxiliaryArray<TAux>(key: string): TAux[] {
    const existing = this.auxiliaryData.get(key) as TAux[] | undefined;
    return existing && Array.isArray(existing) ? existing : [];
  }

  /**
   * Abstract build method to be implemented by generated builders
   * @param context - Optional build context
   */
  abstract build(context?: C): T;
}

/**
 * Creates an inspect method for better debugging experience
 * @param builderName - Name of the builder class
 * @param properties - Current builder properties
 * @returns Formatted string for inspection
 */
export function createInspectMethod(
  builderName: string,
  properties: Record<string, unknown>,
): string {
  return \`\${builderName} { properties: \${JSON.stringify(properties, null, 2)} }\`;
}
`;
